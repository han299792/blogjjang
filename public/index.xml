<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blogjjang</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on blogjjang</description>
    <generator>Hugo</generator>
    <language>kn, en-us</language>
    <lastBuildDate>Wed, 04 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>6월 4일 수요일</title>
      <link>http://localhost:1313/blog/%EB%A9%94%EC%9D%BC%EB%A9%94%EC%9D%BC/6%EC%9B%94-4%EC%9D%BC-%EC%88%98%EC%9A%94%EC%9D%BC/</link>
      <pubDate>Wed, 04 Jun 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/%EB%A9%94%EC%9D%BC%EB%A9%94%EC%9D%BC/6%EC%9B%94-4%EC%9D%BC-%EC%88%98%EC%9A%94%EC%9D%BC/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;NOT IN 쿼리를 사용할 때 발생할 수 있는 문제점에 대해 서술하시오.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;NOT IN 쿼리는 부정조건으로, 주어진 값을 필터링을 해야 하기 때문에 index range scan 대신 fullscan해 더 많은 CPU사용량과 latency를 유발한다. 또한 NULL값 처리에서, NULL비교를 할 때 UNKOWN을 반환해 항상 빈 결과를 반환할 수 있다.&lt;/p&gt;&#xA;&lt;p&gt;이에 대한 대안으로NOT EXISTS와 OUTER JOIN을 사용할 수 있다. NOT EXISTS는 행 단위로 스캔해 매칭되는 첫 행을 찾자마자 중단해 존재하지 않음을 최적으로 확인한다. OUTER JOIN은 pk를 사용하여 최적화된 연산을 수행하고 인덱스를 효과적으로 사용해 NOT IN보다 훨씬 효율적이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>{{title}}</title>
      <link>http://localhost:1313/blog/templates/%EB%8F%85%ED%9B%84%EA%B0%90/</link>
      <pubDate>Tue, 29 Apr 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/templates/%EB%8F%85%ED%9B%84%EA%B0%90/</guid>
      <description>&lt;h1 id=&#34;title&#34;&gt;{{title}}&lt;/h1&gt;&#xA;&lt;p&gt;&lt;em&gt;작성일: {{date:YYYY-MM-DD}}&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>매일매일 5월 4주차 질문</title>
      <link>http://localhost:1313/blog/%EB%A9%94%EC%9D%BC%EB%A9%94%EC%9D%BC/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC/</link>
      <pubDate>Tue, 29 Apr 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/%EB%A9%94%EC%9D%BC%EB%A9%94%EC%9D%BC/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC/</guid>
      <description>&lt;h1 id=&#34;jpa-fetch-join과-페이징을-함께-사용할-때-주의점을-설명해주세요&#34;&gt;JPA Fetch Join과 페이징을 함께 사용할 때 주의점을 설명해주세요&lt;/h1&gt;&#xA;&lt;p&gt;관련 내용: jpa 동작 원리, sql 최적화, 페이징 쿼리의 동작, 컬렉션 패치 조인의 한계&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;JPA 동작 원리&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;자바 객체와 RDB간의 매핑을 자동으로 처리해주는 ORM기술로, 개발자가 직접 SQL 쿼리를 작성하지 않고도 디비 작업을 수행할 수 있게 해줌&lt;/p&gt;&#xA;&lt;p&gt;핵심&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;영속성 컨텍스트&#xA;디비에서 조회한 엔티티 객체를 저장하고 관리하는 일종의 1차 캐시 역할을 한다. 통일한 트랜잭션 내 같은 엔티티를 조회하면 영속성 컨텍스트에 저장된 객체를 반환해 동일함을 보장한다. 엔티티 객체의 상태가 변경되면 자동으로 DB에 반영하는 변경 감지 기능을 수행한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;EntityManager&lt;/strong&gt;&#xA;이 인터페이스를 통해, 영속성 컨텍스트에 엔티티를 저장, 삭제, 조회할 수 있다.&lt;/li&gt;&#xA;&lt;li&gt;write befind / flush&#xA;커밋되기 전까지 쿼리를 바로 디비로 보내지 않고, 내부 임시 저장소에 저장한다. 커밋 시점에 영속성 컨텍스트의 변경 내용을 디비에 동기화하는 작업을 플러시라고 하며, 이때 실제 SQL이 디비에 저장된다.&lt;/li&gt;&#xA;&lt;li&gt;트랜잭션과의 연계&#xA;@Transaction 으로 트랜잭션 관리, 영속성 컨택스트와 연결&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;gradle에-대해-설명해-주세요&#34;&gt;Gradle에 대해 설명해 주세요.&lt;/h1&gt;&#xA;&lt;h1 id=&#34;threadlocal에-대해-설명해-주세요&#34;&gt;ThreadLocal에 대해 설명해 주세요.&lt;/h1&gt;&#xA;&lt;h1 id=&#34;스레드-풀-포화-정책이란-무엇인가요&#34;&gt;스레드 풀 포화 정책이란 무엇인가요?&lt;/h1&gt;&#xA;&lt;h1 id=&#34;어떤-예외가-발생하면-트랜잭션을-롤백하나요&#34;&gt;어떤 예외가 발생하면 트랜잭션을 롤백하나요?&lt;/h1&gt;</description>
    </item>
    <item>
      <title>{{title}}</title>
      <link>http://localhost:1313/blog/templates/%EB%A9%94%EC%9D%BC%EB%A7%A4%EC%9D%BC%EC%9A%A9-%ED%85%9C%ED%94%8C%EB%A6%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/templates/%EB%A9%94%EC%9D%BC%EB%A7%A4%EC%9D%BC%EC%9A%A9-%ED%85%9C%ED%94%8C%EB%A6%BF/</guid>
      <description></description>
    </item>
  </channel>
</rss>
